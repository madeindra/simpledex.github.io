<html>
<head>
<title>Jarppi's P&M Reader</title>
<meta name="description" content="Jarppi's portable Reader for Pictures and Manga">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta charset="UTF-8">
<script>
var dm = false; // dm = true for direct mode. Does not work with current Mangadex API because of CORS. dm = false to proxy queries
// Some shortcuts for common and generic functions
var J=JSON, r=J.parse, s=J.stringify, A=document;
var D = function(p) { return A.getElementById(p) };
var C = function(p) { return A.createElement(p) };
var q = function(method,path,callback) {
	let x = new XMLHttpRequest();
	x.open(method, dm ? path : getProxy(path));
	x.onreadystatechange = function() {
		if (x.readyState == 4) {
			callback(x.status == 200 ? r(x.responseText) : x.responseText, x.status);
		}
	};
	return x;
}
function G(path,callback) {
	try {
		let request = q("GET",path,callback);
		request.send();
	} catch (e) {
		getNewProxy();
		callback(500, "Connection failed. Try again.");
	}
}

/*
 * This POST function is not used
 */
function P(path,data,callback) {
	let request = q("POST",path,callback);
	x.setRequestHeader("Content-type", "application/json");
	x.send(s(data));
}

var proxylist = ["https://jsonp.afeld.me/?url=", "https://gxaxshvw01.execute-api.eu-north-1.amazonaws.com/?url="];
var activeProxy = ~~(Math.random() * proxylist.length);
function getNewProxy() {
	// Get random proxy which is not the same as current proxy
	activeProxy = (activeProxy + 1 + (~~(Math.random() * (proxylist.length - 1)))) % proxylist.length;
	console.log(activeProxy);
}
function getProxy(url) {
	console.log("requesting with proxy: " + proxylist[activeProxy]);
	return proxylist[activeProxy] + escape(url);
}

/*
 * Reader specific stuff below
 */

// Max amount of result pages for big searches
var MAX_PAGES = 100;
var TITLE = "Jarppi's P&M Reader";

// Global static variables for reader
var blockDoujinshi = false;
var currentData = [];
var currentImages = [];
var lastForcedLocale = "";
var idStore = [];
var pendingElements = [];
var STATE_CONTAINER = {};
STATE_CONTAINER.attr = {};

function getCurrentStateUrl() {
	let currentPath = STATE_CONTAINER.localmode ? "?" : "";
	if (notEmpty(STATE_CONTAINER.manga)) {
		currentPath += "/manga/" + STATE_CONTAINER.manga;
		let tmpC = STATE_CONTAINER.chapter;
		let tmpH = STATE_CONTAINER.hash;
		let tmpP = STATE_CONTAINER.page;
		if (notEmpty(tmpC) && notEmpty(tmpH)) {
			currentPath += "/chapter/" + tmpC;
			currentPath += "/" + tmpH;
			currentPath += "/" + (notEmpty(tmpP) ? tmpP : "0");
		}
	} else if (notEmpty(STATE_CONTAINER.search)) {
		currentPath += "/search/" + STATE_CONTAINER.search;
	}
	let attributes = "?";
	for (let i in STATE_CONTAINER.attr) {
		let additionalAttribute = STATE_CONTAINER.attr[i];
		attributes += i + "=" + additionalAttribute + "&";
	}
	if (attributes.length > 1) currentPath += attributes.substring(0, attributes.length-1);
	return currentPath;
}

function getCurrentState() {
	const stateNow = {"manga": STATE_CONTAINER.manga, "chapter": STATE_CONTAINER.chapter, "hash": STATE_CONTAINER.hash, "page": STATE_CONTAINER.page};
	return stateNow;
}
function pushCurrentState() {
	window.history.pushState(getCurrentState(), TITLE, getCurrentStateUrl());
}

function restoreState() {
	// Stuff to state container
}

function notEmpty(param) {
	return param != undefined && param.length > 0;
}

function initPage() {
	let urlLoc = document.location.href;
	let urlStartSign = "//";
	let urlParamStart = urlLoc.indexOf('/', urlStartSign.length + urlLoc.indexOf(urlStartSign)); // offsetting the uri:// part
	if (urlLoc.indexOf("http") != 0) {
		urlParamStart = urlLoc.indexOf('?');
		STATE_CONTAINER.localmode = true;
		console.log("Local mode enabled");
	}
	let urlParamPart = urlLoc.substring(urlParamStart);
	console.log("parsing url parameters from " + urlParamPart);
	if (urlParamStart >= 0) {
		let urlParamsIdx = urlParamPart.indexOf('?', 1);
		let urlParams = [];
		if (urlParamsIdx >= 0) {
			urlParams = urlParamPart.substring(1 + urlParamsIdx).split('&');
			urlParamPart = urlParamPart.substring(0, urlParamsIdx);
		}
		for (let i in urlParams) {
			let keypair = urlParams[i].split("=");
			if (keypair.length == 2) STATE_CONTAINER.attr[keypair[0]] = keypair[1];
		}
		let urlParts = urlParamPart.split('/');
		for (let i = 0; i < urlParts.length; i++) {
			if (urlParts[i] == "manga" && urlParts.length - 1 > i) {
				STATE_CONTAINER.manga = urlParts[i+1];
			} else if (urlParts[i] == "chapter") {
				if (urlParts.length - 3 > i) {
					STATE_CONTAINER.chapter = urlParts[i+1];
					STATE_CONTAINER.hash = urlParts[i+2];
					STATE_CONTAINER.page = urlParts[i+3];
				} else if (urlParts.length - 2 > i) {
					STATE_CONTAINER.chapter = urlParts[i+1];
					STATE_CONTAINER.hash = urlParts[i+2];
				}
			} else if (urlParts[i] == "search" && urlParts.length - 1 > i) {
				STATE_CONTAINER.search = urlParts[i+1];
			}
		}
		
		//restoreSession();
	}
}

/*
 * State should reflect current status of the page. No cookies.
 * Everything comes from url and gets requested via API if that
 * is needed.
 *
 * Valid states should be:
 * manga populated: /manga/{id} - this shows feed for manga
 * manga+chapter+hash(+page) populated: - this shows an opened
 *     chapter (with page number browsed to if present)
 *
 * Any real content is not stored in page and is either fetched
 * from current STATE_CONTAINER or via APIs if not present.
 */
function restoreSession() {
	let lang = STATE_CONTAINER["lang"];
	if (STATE_CONTAINER["chapter"] != undefined) {
		// No support yet
	} else if (STATE_CONTAINER["manga"] != undefined) {
		G("https://api.mangadex.org/manga/"+STATE_CONTAINER["manga"]+"/feed?order[chapter]=desc&"+(lang!=undefined?"&locales[]="+lang:"")+"&limit=500",populateChapters);
	} else if (STATE_CONTAINER["search"] != undefined) {
		D("search_term").value = STATE_CONTAINER["search"];
		search();
	}
}

function createCachedElement(id, elementType) {
	let newElement = C(elementType);
	newElement.textId = id;
	if (idStore[id] != undefined) {
		newElement.innerText = unescape(idStore[id]);
	} else {
		newElement.innerText = id.substring(0,6) + "...";
		pendingElements.push(newElement);
	}
	
	return newElement;
}

function searchInput(evt){
	if (evt.keyCode == 13) {
		evt.preventDefault();
		search();
	}
}

function tidyDescription(rawDesc) {
	if (rawDesc == null) return "";
	// Thanks! u/thuniffe
	return rawDesc.replace(/\[(\/?[biu]|hr)\]/g,"<$1>").replaceAll("[*]","<br />").replace(/\r?\n/g,"<br />")
	.replace(/\[img\]([^\[]+)\[\/img\]/g,'<img src="$1">').replace(/\[url\=([^\]]+)\]([^\[]+)\[\/url\]/g,'<a href="$1">$2</a>')
	.replace(/\[spoiler\]/gi,'<span class="spoiler">').replace(/\[\/spoiler\]/gi,'</span>');
}

function createLanguageButtons(languageCodes) {
	if (languageCodes.length > 0) {
		let optionsForm = D("search_options");
		for (let i in languageCodes) {
			let tmpButton = C("input");
			let tmpId = languageCodes[i];
			tmpButton.type = "radio";
			tmpButton.id = tmpId;
			tmpButton.value = tmpId;
			tmpButton.name = "language";
			tmpButton.addEventListener("change", () => {
				lastForcedLocale = tmpId;
				G("https://api.mangadex.org/manga/"+STATE_CONTAINER.manga+"/feed?locales[]="+lastForcedLocale+"&order[chapter]=desc&limit=500",populateChapters);
			});
			optionsForm.appendChild(tmpButton);
			let tmpLabel = C("label");
			tmpLabel.for = tmpId;
			tmpLabel.innerText = tmpId;
			optionsForm.appendChild(tmpLabel);
			optionsForm.appendChild(C("br"));
		}
	}
}

function clearSearchOptions() {
	let optionsForm = D("search_options");
	while (optionsForm.firstChild) optionsForm.removeChild(optionsForm.firstChild);
}

function splitTermToTitles(searchTerm) {
	if (searchTerm.indexOf(' ') < 0) return searchTerm;
	return searchTerm.trim().split(' ').join("+");
}

function getIdsForType(relationsList, type) {
	let matchedTypeIds = [];
	for (let i in relationsList) {
		if (relationsList[i].type == type) matchedTypeIds.push(relationsList[i].id);
	}
	return matchedTypeIds;
}

function getIdForType(relationsList, type) {
	for (let i in relationsList) {
		if (relationsList[i].type == type) return relationsList[i].id;
	}
	return "none";
}

function search() {
	blockDoujinshi = false;
	performSearch();
}

function searchOfficial() {
	blockDoujinshi = true;
	performSearch();
}

function performSearch() {
	clearSearchOptions();
	STATE_CONTAINER.search = splitTermToTitles(D("search_term").value);
	lastForcedLocale = "";
	//window.history.pushState({"action": "search", "keyword": STATE_CONTAINER.search, "doujin": blockDoujinshi}, TITLE, "?search=" + STATE_CONTAINER.search + (blockDoujinshi?"doujinblock=true":""));
	pushCurrentState();
	G("https://api.mangadex.org/manga?title="+STATE_CONTAINER.search+(blockDoujinshi?"&excludedTags[]=b13b2a48-c720-44a9-9c77-39c9979373fb":"")+"&limit=100",populateManga);
}

function clearHud() {
	D("manga_name").innerText = "-";
	D("chapter_num").innerText = "-";
}

function populateError(parent, code, text) {
	clearHud();
	D("search_info").innerHTML = "Error " + code;
	if (text != null && text.length > 0) {
		parent.appendChild(addCell(C("tr"), text));
	}
}

function addCell(parent, text) {
	let tmp = C("td");
	tmp.innerHTML=text;
	parent.appendChild(tmp);
	return tmp;
}

function getAuthors(relationsList) {
	let authorIds = getIdsForType(relationsList, "author");
	let artistIds = getIdsForType(relationsList, "artist");
	let creatorContainer = C("div");
	let rawIds = [];
	for (let i in authorIds) {
		creatorContainer.appendChild(createCachedElement(authorIds[i], "p"));
		rawIds.push(authorIds[i]);
	}
	if (artistIds.length > 0) {
		let artistHeader = C("p");
		artistHeader.style.display = "inline";
		artistHeader.innerHTML = "<b>Artist" + (artistIds.length>1 ?"s":"") + "<b/>: ";
		creatorContainer.appendChild(artistHeader);
		for (let i in artistIds) {
			creatorContainer.appendChild(createCachedElement(artistIds[i], "p"));
			rawIds.push(artistIds[i]);
		}
	}
	return {"node": creatorContainer, "ids": authorIds.concat(rawIds)};
}

function populateCache(resultJson, resultCode) {
	let resultList = resultJson != null ? resultJson.results : [];
	if (resultCode == 200 && resultList.length > 0) {
		for (let result in resultList) {
			let co = resultList[result];
			let coi = co.data.id;
			let cot = co.data.type;
			if (idStore[cot+coi] == undefined) {
				idStore[cot+coi] = co.data.attributes.name;
			}
		}
		let matchedPendingElements = [];
		for (let pe in pendingElements) {
			let cpe = pendingElements[pe];
			if (idStore[cpe.textId] != undefined) {
				cpe.innerText = unescape(idStore[cpe.textId]);
				matchedPendingElements.push(cpe);
			}
		}
		for (let me in matchedPendingElements) {
			pendingElements.pop(matchedPendingElements[me]);
		}
	}
}

function populateManga(resultJson, resultCode) {
	let a = D("search_results");
	clearHud();
	while (a.firstChild) {
		a.removeChild(a.firstChild);
	}
	let resultList = resultJson != null ? resultJson.results : [];
	if (resultCode == 200 && resultList.length > 0) {
		let row = C("tr");
		addCell(row,"Title").style.width = "20%";
		addCell(row,"Description").style.width = "70%";
		addCell(row,"Author(s)").style.width = "10%";
		a.appendChild(row);
		resultList.sort(nameSort);
		let authorIds = [];
		for (let resultObj in resultList) {
			let row = C("tr");
			let mangaName = unescape(resultList[resultObj].data.attributes.title.en);
			let mangaId = resultList[resultObj].data.id;
			let mangaNameCell = addCell(row, mangaName);
			let descriptionContainer = C("div");
			descriptionContainer.classList.add("description");
			descriptionContainer.innerHTML = tidyDescription(unescape(resultList[resultObj].data.attributes.description.en));
			row.appendChild(descriptionContainer);
			mangaNameCell.classList.add("link");
			mangaNameCell.addEventListener("click", () => {
				//window.history.pushState({"action": "feed", "mangaId": mangaId, "offset": 0}, TITLE, "?manga=" + mangaId);
				STATE_CONTAINER.manga = mangaId;
				STATE_CONTAINER.attr.mangaName = mangaName;
				pushCurrentState();
				G("https://api.mangadex.org/manga/"+mangaId+"/feed?order[chapter]=desc&limit=500",populateChapters);
			});
			let authorCell = C("td");
			let authorResults = getAuthors(resultList[resultObj].relationships);
			for (let authorId in authorResults.ids) {
				let tmpId = authorResults.ids[authorId];
				if (idStore["author"+tmpId] == undefined && authorIds.indexOf(tmpId) < 0) {
					authorIds.push(tmpId);
				}
			}
			authorCell.appendChild(authorResults.node);
			row.appendChild(authorCell);
			a.appendChild(row);
		}
		D("search_info").innerHTML = resultJson.total + " manga found!";
		if (resultJson.limit < resultJson.total) {
			createMangaPageButtons(resultJson.total, 3, "https://api.mangadex.org/manga?title="+STATE_CONTAINER.search+"&limit=100&offset=");
		}
		if (authorIds.length > 0) {
			// TODO: multiple queries needed if over 100 different authors + artists. This can happen :(
			// For now only taking the first 100
			// Edit: removed authors for now, too many extra queries
			//G("https://api.mangadex.org/author?ids[]="+authorIds.splice(0,100).join('&ids[]=')+"&limit=100",populateCache);
		}
	} else {
		if (resultCode == 204) {
			D("search_info").innerHTML = "No results";
		} else {
			populateError(a, resultCode, resultJson);
		}
	}
}

function createMangaPageButtons(total, tableCols, pageBaseUrl) {
	createPageButtons(total, tableCols, pageBaseUrl, 100, populateManga);
}

function createChapterPageButtons(total, tableCols, pageBaseUrl) {
	createPageButtons(total, tableCols, pageBaseUrl, 500, populateChapters);
}

function createPageButtons(total, tableCols, pageBaseUrl, maxResults, callback) {
	let row = C("tr");
	let cell = C("td");
	cell.colSpan=tableCols;
	let pages = Math.ceil(total / maxResults);
	if (pages > MAX_PAGES) pages = MAX_PAGES;
	for (let i = 0; i < pages; i++) {
		let pageLink = C("div");
		pageLink.style.float="left";
		pageLink.style.margin="0.3em";
		pageLink.classList.add("link");
		pageLink.innerHTML = "Page " + (i+1);
		let offset=maxResults*i;
		pageLink.addEventListener("click", ()=>{
			G(pageBaseUrl+offset,callback);
		});
		cell.appendChild(pageLink);
	}
	row.appendChild(cell);
	D("search_results").appendChild(row);
}

function populateChapters(resultJson, resultCode) {
	let a = D("search_results");
	while (a.firstChild) {
		a.removeChild(a.firstChild);
	}
	let resultList = resultJson != null ? resultJson.results : [];
	if (resultCode == 200 && resultList.length > 0) {
		let row = C("tr");
		let scanlationGroupIds = [];
		let languageIds = [];
		addCell(row,"Chapter");
		addCell(row,"Title");
		addCell(row,"Language");
		addCell(row,"ScanGroup");
		//addCell(row,"Date");
		a.appendChild(row);
		resultList.sort(chapterSort);
		D("manga_name").innerHTML = STATE_CONTAINER.attr.mangaName;
		
		for (let resultObj in resultList) {
			let row = C("tr");
			let chapterId = resultList[resultObj].data.id;
			let hashId = resultList[resultObj].data.attributes.hash;
			let pagesData = resultList[resultObj].data.attributes.dataSaver;
			let chapterNumber = resultList[resultObj].data.attributes.chapter;
			let languageId = unescape(resultList[resultObj].data.attributes.translatedLanguage);
			addCell(row, chapterNumber);
			addCell(row, unescape(resultList[resultObj].data.attributes.title));
			addCell(row, languageId);
			if (languageIds.indexOf(languageId) < 0) languageIds.push(languageId);
			let scanGroupType = "scanlation_group";
			let scanGroupIdRaw = getIdForType(resultList[resultObj].relationships, scanGroupType);
			let scanGroupId = scanGroupType + scanGroupIdRaw;
			let scanGroupContainer = createCachedElement(scanGroupIdRaw, "p");
			let scanGroupCell = C("td");
			scanGroupCell.appendChild(scanGroupContainer);
			row.appendChild(scanGroupCell);
			if (scanlationGroupIds.indexOf(scanGroupIdRaw)<0 && idStore.indexOf(scanGroupIdRaw)<0) scanlationGroupIds.push(scanGroupIdRaw);
			//addCell(row, (new Date(resultList[resultObj].data.attributes.publishAt)).toLocaleString());
			row.classList.add("link");
			row.addEventListener("click",()=> {
				prepareReader(chapterId, chapterNumber, hashId, pagesData);
			});
			a.appendChild(row);
		}
		D("search_info").innerHTML = resultJson.total + " chapter" + (resultJson.total != 1 ? "s":"") + " found!";
		if (resultJson.limit < resultJson.total) {
			createChapterPageButtons(resultJson.total, 3, "https://api.mangadex.org/manga/"+STATE_CONTAINER.manga+"/feed?" + (lastForcedLocale.length>0)?"locales[]="+lastForcedLocale+"&":"" + "order[chapter]=desc&limit=500&offset=");
		}
		// Removed scanlation group population for now
		// if (scanlationGroupIds.length > 0) G("https://api.mangadex.org/group?ids[]="+scanlationGroupIds.slice(0,100).join('&ids[]=')+"&limit=100",populateCache);
		if (lastForcedLocale.length == 0 && languageIds.length > 0) createLanguageButtons(languageIds, STATE_CONTAINER.manga);
	} else {
		if (resultCode == 204) {
			D("search_info").innerHTML = "No results";
		} else {
			populateError(a, resultCode, resultJson);
		}
	}
}

function nameSort(a,b){
	return a.data.attributes.title.en.localeCompare(b.data.attributes.title.en);
}

function chapterSort(a,b) {
	if (!isNaN(parseFloat(a.data.attributes.chapter)) && !isNaN(parseFloat(b.data.attributes.chapter))) return parseFloat(b.data.attributes.chapter) - parseFloat(a.data.attributes.chapter);
	if (b.data.attributes.chapter == null) return -1;
	if (a.data.attributes.chapter == null) return 1;
	return b.data.attributes.chapter.localeCompare(a.data.attributes.chapter);

}

function populateImages(serverJson) {
	let atHome = serverJson.baseUrl;
	let imgRoot = atHome + "/data-saver/" + STATE_CONTAINER.hash + "/";
	currentImages = [];
	for (let i in currentData) {
		var newImg = C("img");
		newImg.src=imgRoot + currentData[i];
		currentImages.push(newImg);
	}
	refreshView();
}

function refreshView(){
	if (currentImages.length == 0 || STATE_CONTAINER.page >= currentImages.length || STATE_CONTAINER.page < 0){
		console.log("Invalid images");
		return;
	}
	let vtmp = D("view_mid");
	if (vtmp.firstChild != null) vtmp.removeChild(vtmp.firstChild);
	vtmp.appendChild(currentImages[STATE_CONTAINER.page]);
	
	vtmp = D("view_right");
	if (vtmp.firstChild != null) vtmp.removeChild(vtmp.firstChild);
	if (STATE_CONTAINER.page > 0) {
		vtmp.appendChild(currentImages[STATE_CONTAINER.page-1]);
	}
	
	vtmp = D("view_left");
	if (vtmp.firstChild != null) vtmp.removeChild(vtmp.firstChild);
	if (STATE_CONTAINER.page+1 < currentImages.length) {
		vtmp.appendChild(currentImages[STATE_CONTAINER.page+1]);
	}
	
	D("search").style.display="none";
	D("view").style.display="block";
}

function prepareReader(chapterId, chapterNumber, hashId, pagesData) {
	STATE_CONTAINER.chapter = chapterId;
	STATE_CONTAINER.hash = hashId;
	currentData = pagesData;
	STATE_CONTAINER.page = 0;
	D("chapter_num").innerText = chapterNumber;
	G("https://api.mangadex.org/at-home/server/"+chapterId,populateImages);
}

function movePage(step){
	STATE_CONTAINER.page += step;
	pushCurrentState();
	if (STATE_CONTAINER.page < 0) STATE_CONTAINER.page = 0;
	else if (currentImages != null && STATE_CONTAINER.page >= currentImages.length) STATE_CONTAINER.page = currentImages.length-1;
	refreshView();
}

function showSearch() {
	D("view").style.display="none";
	D("search").style.display="block";
}

function shortcuts(evt) {
	if (evt.srcElement == D("search_term")) return;
	if (evt.keyCode == 37 || evt.keyCode == 65) {
		movePage(1)
	} else if (evt.keyCode == 39 || evt.keyCode == 68) {
		movePage(-1);
	}
}

document.addEventListener("keydown", shortcuts);

window.onpopstate = function(event) {
	if (event.state != undefined) {
		// TODO
	}
}

window.onload = function() {
	initPage();
};

</script>
<style>
body {background-color:#c0fefe}
input[type=button] {margin: 0 1em;}
#view {display:none;width=100%;height:100%}
#search {display:block;width:80%;margin:auto;padding:2em;background-color:#f9fdfe}
#search_results {display:inline-block}
#search_results tr {background-color:#fafafa;margin:0.5em}
#search_results tr:nth-child(odd) {background-color:#e6e2e1;margin:0.5em}
.description {max-height:18em;overflow-y:auto}
.spoiler {display:block}
.spoiler:not(:hover) {text-color:#101010;background-color:#101010;max-width:20%;max-height:2em;display:block;overflow:hidden}
.spoiler:not(:hover)>a {text-decoration:none;color:inherit}
.link,.view_preview {cursor:pointer;text-decoration:none;color:inherit}
.view_preview img {margin-top:5%;float:left;width:5%}
.view_main img {margin:auto;float:left;width:80%;object-fit:contain}
</style>
</head>
<body>
<div id="view">
<input type="button" onclick="showSearch()" value="Back to Search"/>
<div id="view_left" onclick=movePage(1) class="view_preview"></div>
<div id="view_mid" class="view_main"></div>
<div id="view_right" onclick=movePage(-1) class="view_preview"></div>
</div>
<div id="search">
<h3>SimpleDex v0.1.8</h3>
<table>
<tr>
<td colspan="2"><p>Search for:</p></td>
</tr>
<tr>
<td><input type="text" id="search_term" onkeydown="searchInput(event)"/></td>
<td>
<input type="button" onclick="search()" value="Search All Manga"/>
<input type="button" onclick="searchOfficial()" value="Search Without Doujinshi"/>
</td>
</tr>
<tr>
<td><label for="search_term" id="search_info"></label></td>
</tr>
</table>
<div><form id="search_options"></form></div>
<div id="manga_name">-</div>
<div id="chapter_num">-</div>
<table id="search_results"></table>
</div>
</body>
</html>